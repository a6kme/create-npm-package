#!/usr/bin/env node

const inquirer = require('inquirer');
const chalk = require('chalk');
const fs = require('fs-extra');
const path = require('path');
const os = require('os');
const validateProjectName = require('validate-npm-package-name');

function validateUsername(username) {
  if (username.match(/^[-a-z0-9_]/)) {
    return true;
  }
  return false;
}

/******* Below code snippets are taken from https://github.com/facebook/create-react-app/ *******/

// These files should be allowed to remain on a failed install,
// but then silently removed during the next create.
const errorLogFilePatterns = [
  'npm-debug.log',
  'yarn-error.log',
  'yarn-debug.log'
];

// If project only contains files generated by GH, itâ€™s safe.
// Also, if project contains remnant error logs from a previous
// installation, lets remove them now.
// We also special case IJ-based products .idea because it integrates with CRA:
// https://github.com/facebook/create-react-app/pull/368#issuecomment-243446094
function isSafeToCreateProjectIn(root, name) {
  const validFiles = [
    '.DS_Store',
    'Thumbs.db',
    '.git',
    '.gitignore',
    '.idea',
    'README.md',
    'LICENSE',
    '.hg',
    '.hgignore',
    '.hgcheck',
    '.npmignore',
    'mkdocs.yml',
    'docs',
    '.travis.yml',
    '.gitlab-ci.yml',
    '.gitattributes'
  ];
  console.log();

  const conflicts = fs
    .readdirSync(root)
    .filter(file => !validFiles.includes(file))
    // IntelliJ IDEA creates module files before CRA is launched
    .filter(file => !/\.iml$/.test(file))
    // Don't treat log files from previous installation as conflicts
    .filter(
      file => !errorLogFilePatterns.some(pattern => file.indexOf(pattern) === 0)
    );

  if (conflicts.length > 0) {
    console.log(
      `The directory ${chalk.green(name)} contains files that could conflict:`
    );
    console.log();
    for (const file of conflicts) {
      console.log(`  ${file}`);
    }
    console.log();
    console.log(
      'Either try using a new directory name, or remove the files listed above.'
    );

    return false;
  }

  // Remove any remnant files from a previous installation
  const currentFiles = fs.readdirSync(path.join(root));
  currentFiles.forEach(file => {
    errorLogFilePatterns.forEach(errorLogFilePattern => {
      // This will catch `(npm-debug|yarn-error|yarn-debug).log*` files
      if (file.indexOf(errorLogFilePattern) === 0) {
        fs.removeSync(path.join(root, file));
      }
    });
  });
  return true;
}

/****** Code snippets end ******/

function createNpmPackage() {
  // TODO: Also used commander, and skip prompts if configurations are given.
  // A user of CLI can also invoke it using a script
  inquirer
    .prompt([
      {
        type: 'input',
        name: 'packageName',
        message: 'What package name do you want?',
        validate: function(value) {
          if (!value) {
            return 'package name can not be empty';
          }
          if (validateProjectName(value).validForNewPackages) {
            return true;
          }
          return `Can not create a project called ${chalk.red(
            `"${value}"`
          )} because of npm naming restrictions`;
        }
      },
      {
        type: 'list',
        name: 'jsType',
        message: 'What JavaScript flavour you want?',
        choices: ['ES5', 'ES6', 'TypeScript']
      },
      {
        type: 'input',
        name: 'npmUsername',
        message: 'What is your npmjs.com username?',
        validate: function(value) {
          if (!value) {
            return 'username can not be empty';
          }
          if (validateUsername(value)) {
            return true;
          }
          return `Please check the username ${chalk.red(`"${value}"`)}`;
        }
      },
      {
        type: 'input',
        name: 'githubUsername',
        message: 'What is your github.com username?',
        validate: function(value) {
          if (!value) {
            return 'username can not be empty';
          }
          if (validateUsername(value)) {
            return true;
          }
          return `Please check the username ${chalk.red(`"${value}"`)}`;
        }
      },
      {
        type: 'confirm',
        name: 'willUseInBrowser',
        message: `Are you creating this package to be used as a ${chalk.magenta(
          `"<script>"`
        )} tag in Browser?`
      }
    ])
    .then(answeres => {
      run(answeres);
    });
}

createNpmPackage();

/**
 * Run after taking prompts from user for creating the package
 *
 * @param {*} { packageName, npmUsername, githubUsername, jsType }
 */
function run({ packageName, npmUsername, githubUsername, jsType }) {
  const root = path.resolve(packageName);
  const appName = path.basename(root);

  // Create a directory with package-name
  fs.ensureDirSync(appName);

  // If there are conflicting files in the directory, which we might override,
  // do not proceed
  if (!isSafeToCreateProjectIn(root, appName)) {
    process.exit(1);
  }

  // Start creating package.json at the destination
  const packageJson = {
    name: `@${npmUsername}/${appName}`, // Creating scoped package to reduce name conflicts
    version: '0.1.0',
    private: true,
    repository: {
      type: 'git',
      url: `https://github.com/${githubUsername}/${appName}.git`
    },
    author: npmUsername,
    engines: {
      node: '>=8.10'
    }
  };
  fs.writeFileSync(
    path.join(root, 'package.json'),
    JSON.stringify(packageJson, null, 2) + os.EOL
  );

  copyTemplateFilesToRoot(jsType, root);
}

function copyTemplateFilesToRoot(jsType, root) {
  // Name of template directory from jsType es5/ es6/ typescript
  const templateDir = `/template-${jsType.toLowerCase()}`;

  // Copy the template files to root
  fs.copySync(path.join(__dirname, '/templates', templateDir), root);

  // Copy common linting and config files
  fs.copySync(path.join(__dirname, '/templates/common'), root);
}
