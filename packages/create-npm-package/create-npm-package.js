#!/usr/bin/env node
const os = require('os');
const path = require('path');
const fs = require('fs-extra');
const chalk = require('chalk');
var spawn = require('cross-spawn');
const inquirer = require('inquirer');
const { validateUsername } = require('./utils');
const execSync = require('child_process').execSync;
const validateProjectName = require('validate-npm-package-name');

/******* Below code snippets are taken from https://github.com/facebook/create-react-app/ *******/

// These files should be allowed to remain on a failed install,
// but then silently removed during the next create.
const errorLogFilePatterns = [
  'npm-debug.log',
  'yarn-error.log',
  'yarn-debug.log'
];

// If project only contains files generated by GH, itâ€™s safe.
// Also, if project contains remnant error logs from a previous
// installation, lets remove them now.
// We also special case IJ-based products .idea because it integrates with CRA:
// https://github.com/facebook/create-react-app/pull/368#issuecomment-243446094
function isSafeToCreateProjectIn(root, name) {
  const validFiles = [
    '.DS_Store',
    'Thumbs.db',
    '.git',
    '.gitignore',
    '.idea',
    'README.md',
    'LICENSE',
    '.hg',
    '.hgignore',
    '.hgcheck',
    '.npmignore',
    'mkdocs.yml',
    'docs',
    '.travis.yml',
    '.gitlab-ci.yml',
    '.gitattributes'
  ];
  console.log();

  const conflicts = fs
    .readdirSync(root)
    .filter(file => !validFiles.includes(file))
    // IntelliJ IDEA creates module files before CRA is launched
    .filter(file => !/\.iml$/.test(file))
    // Don't treat log files from previous installation as conflicts
    .filter(
      file => !errorLogFilePatterns.some(pattern => file.indexOf(pattern) === 0)
    );

  if (conflicts.length > 0) {
    console.log(
      `The directory ${chalk.green(name)} contains files that could conflict:`
    );
    console.log();
    for (const file of conflicts) {
      console.log(`  ${file}`);
    }
    console.log();
    console.log(
      'Either try using a new directory name, or remove the files listed above.'
    );

    return false;
  }

  // Remove any remnant files from a previous installation
  const currentFiles = fs.readdirSync(path.join(root));
  currentFiles.forEach(file => {
    errorLogFilePatterns.forEach(errorLogFilePattern => {
      // This will catch `(npm-debug|yarn-error|yarn-debug).log*` files
      if (file.indexOf(errorLogFilePattern) === 0) {
        fs.removeSync(path.join(root, file));
      }
    });
  });
  return true;
}

/****** Code snippets end ******/

function isInGitRepository(appPath) {
  try {
    execSync('git rev-parse --is-inside-work-tree', {
      cwd: appPath,
      stdio: 'ignore'
    });
    return true;
  } catch (e) {
    return false;
  }
}

function isInMercurialRepository(appPath, repositoryPath) {
  try {
    execSync('hg --cwd . root', { cwd: appPath, stdio: 'ignore' });
    return true;
  } catch (e) {
    return false;
  }
}

function tryGitInit(appPath) {
  let didInit = false;
  let options = { cwd: appPath, stdio: 'ignore' };
  try {
    execSync('git --version', options);

    if (isInGitRepository() || isInMercurialRepository()) {
      return false;
    }

    execSync('git init', options);
    didInit = true;

    execSync(`git remote add origin ${repositoryPath}`, options);

    execSync('git add -A', options);
    execSync('git commit -m "Initial commit from Create Npm Package"', options);
    return true;
  } catch (e) {
    if (didInit) {
      // If we successfully initialized but couldn't commit,
      // maybe the commit author config is not set.
      // In the future, we might supply our own committer
      // like Ember CLI does, but for now, let's just
      // remove the Git files to avoid a half-done state.
      try {
        // unlinkSync() doesn't work on directories.
        fs.removeSync(path.join(appPath, '.git'));
      } catch (removeErr) {
        // Ignore.
      }
    }
    return false;
  }
}

function createNpmPackage() {
  // TODO: Also used commander, and skip prompts if configurations are given.
  // A user of CLI can also invoke it using a script
  inquirer
    .prompt([
      {
        type: 'input',
        name: 'packageName',
        message: 'What package name do you want?',
        validate: function(value) {
          if (!value) {
            return 'package name can not be empty';
          }
          if (validateProjectName(value).validForNewPackages) {
            return true;
          }
          return `Can not create a project called ${chalk.red(
            `"${value}"`
          )} because of npm naming restrictions`;
        }
      },
      {
        type: 'list',
        name: 'jsType',
        message: 'What JavaScript flavour you want?',
        choices: ['ES5', 'ES6', 'TypeScript']
      },
      {
        type: 'input',
        name: 'npmUsername',
        message: 'What is your npmjs.com username?',
        validate: function(value) {
          if (!value) {
            return 'username can not be empty';
          }
          if (validateUsername(value)) {
            return true;
          }
          return `Please check the username ${chalk.red(`"${value}"`)}`;
        }
      },
      {
        type: 'input',
        name: 'githubUsername',
        message: 'What is your github.com username?',
        validate: function(value) {
          if (!value) {
            return 'username can not be empty';
          }
          if (validateUsername(value)) {
            return true;
          }
          return `Please check the username ${chalk.red(`"${value}"`)}`;
        }
      },
      {
        type: 'confirm',
        name: 'willUseInBrowser',
        message: `Are you creating this package to be used as a ${chalk.magenta(
          `"<script>"`
        )} tag in Browser?`
      }
    ])
    .then(answeres => {
      run(answeres);
    });
}

createNpmPackage();

/**
 * Run after taking prompts from user for creating the package
 *
 * @param {*} { packageName, npmUsername, githubUsername, jsType }
 */
function run({ packageName, npmUsername, githubUsername, jsType }) {
  const root = path.resolve(packageName);
  const appName = path.basename(root);

  // Create a directory with package-name
  fs.ensureDirSync(appName);

  // If there are conflicting files in the directory, which we might override,
  // do not proceed
  if (!isSafeToCreateProjectIn(root, appName)) {
    process.exit(1);
  }

  // Start creating package.json at the destination
  const packageJson = {
    name: `@${npmUsername}/${appName}`, // Creating scoped package to reduce name conflicts
    version: '0.1.0',
    private: true,
    repository: {
      type: 'git',
      url: `https://github.com/${githubUsername}/${appName}.git`
    },
    author: npmUsername,
    engines: {
      node: '>=8.10'
    }
  };
  fs.writeFileSync(
    path.join(root, 'package.json'),
    JSON.stringify(packageJson, null, 2) + os.EOL
  );

  // Copy template files to new package folder
  copyTemplateFilesToRoot(jsType, root);

  // Run npm install in the directory to install the packages
  installDevDependencies(jsType, root);

  // Initialize a git repository
  if (tryGitInit(root, packageJson.repository.url)) {
    console.log();
    console.log(chalk.green('Initialized a git repository.'));
  }
}

function copyTemplateFilesToRoot(jsType, root) {
  // Name of template directory from jsType es5/ es6/ typescript
  const templateDir = `/template-${jsType.toLowerCase()}`;

  // Copy the template files to root
  fs.copySync(path.join(__dirname, '/templates', templateDir), root);

  // Copy common linting and config files
  fs.copySync(path.join(__dirname, '/templates/common'), root);
}

/**
 * Get devDependencies for appropriate JavaScript flavour
 *
 * @param {*} jsType
 * @returns devDependencies
 */
function installDevDependencies(jsType, root) {
  let devDependencies = [];
  const commonDependencies = [
    'eslint',
    'eslint-config-prettier',
    'eslint-plugin-prettier',
    'jest',
    'prettier',
    'webpack',
    'webpack-cli'
  ];

  if (jsType === 'ES6') {
    devDependencies = [
      '@babel/core',
      '@babel/preset-env',
      'babel-eslint',
      'babel-loader'
    ];
  } else if (jsType === 'TypeScript') {
    devDependencies = ['typescript'];
  }

  const command = 'npm';
  const args = ['install', '--save-dev'];
  commonDependencies.forEach(function(value) {
    args.push(value);
  });
  devDependencies.forEach(function(value) {
    args.push(value);
  });

  console.log(chalk.green('Installing dependencies...'));
  console.log();

  const proc = spawn.sync(command, args, { cwd: root, stdio: 'inherit' });
  if (proc.status !== 0) {
    console.error(`\`${command} ${args.join(' ')}\` failed`);
    return;
  }
}
